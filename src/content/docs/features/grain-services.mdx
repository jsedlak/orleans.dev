---
title: Grain Services
description: Special grains that run on every silo from startup to shutdown with no stable identity, used for distributed infrastructure responsibilities.
---

import { Steps, Tabs, TabItem, Card, CardGrid, Aside } from "@astrojs/starlight/components";

**Grain services** are special grains that run automatically on every silo from startup to shutdown. Unlike regular grains, grain services have no stable identity and are not activated on demand — they are system-level components used to distribute infrastructure responsibilities across the cluster. Orleans uses grain services internally to implement features like the reminder system.

## How They Differ from Regular Grains

| Property | Regular Grain | Grain Service |
|---|---|---|
| Identity | Unique, stable key | No user-facing identity |
| Activation | On demand | Automatic on silo startup |
| Lifecycle | Activated/deactivated by runtime | Runs for the silo's lifetime |
| Instances | One per identity in the cluster | One per silo |
| Use case | Application logic | Infrastructure, background processing |

## Implementing a Grain Service

### 1. Define the Interface

Grain service interfaces extend `IGrainService`:

```csharp
public interface ICleanupService : IGrainService
{
    ValueTask ForceCleanup();
}
```

### 2. Implement the Grain Service

Grain services extend `GrainService`:

```csharp
public class CleanupService : GrainService, ICleanupService
{
    private readonly ILogger<CleanupService> _logger;
    private IGrainTimer? _timer;

    public CleanupService(
        IServiceProvider services,
        GrainId grainId,
        Silo silo,
        ILoggerFactory loggerFactory)
        : base(grainId, silo, loggerFactory)
    {
        _logger = loggerFactory.CreateLogger<CleanupService>();
    }

    public override Task Init(IServiceProvider serviceProvider)
    {
        _timer = RegisterGrainTimer(
            callback: static async (state, ct) =>
            {
                state._logger.LogInformation("Running scheduled cleanup");
                await state.PerformCleanupAsync();
            },
            state: this,
            options: new GrainTimerCreationOptions
            {
                DueTime = TimeSpan.FromMinutes(1),
                Period = TimeSpan.FromMinutes(10)
            });

        return base.Init(serviceProvider);
    }

    public async ValueTask ForceCleanup()
    {
        _logger.LogInformation("Forced cleanup requested");
        await PerformCleanupAsync();
    }

    private Task PerformCleanupAsync()
    {
        // Cleanup logic here
        return Task.CompletedTask;
    }
}
```

### 3. Register the Grain Service

Register the grain service on the silo builder:

```csharp
siloBuilder.AddGrainService<CleanupService>();
```

<Aside>
  Grain services are instantiated once per silo. The `GrainId` passed to the constructor is generated by the runtime and is not meaningful to application code.
</Aside>

## Calling a Grain Service

To call a grain service from a regular grain, use `IGrainServiceClient<T>`:

```csharp
public interface ICleanupServiceClient : IGrainServiceClient<ICleanupService>
{
    // Mirror the service methods
    ValueTask ForceCleanup();
}
```

Inject and use the client:

```csharp
public class AdminGrain : Grain, IAdminGrain
{
    private readonly ICleanupServiceClient _cleanup;

    public AdminGrain(ICleanupServiceClient cleanup)
    {
        _cleanup = cleanup;
    }

    public async ValueTask TriggerCleanup()
    {
        await _cleanup.ForceCleanup();
    }
}
```

## Grain Service Lifecycle

<Steps>
1. **Silo startup** — the grain service is instantiated and its constructor runs.

2. **Init** — the `Init` method is called with the silo's `IServiceProvider`. Set up timers, subscriptions, and initial state here.

3. **Running** — the grain service processes calls and timer callbacks, respecting the single-threaded model.

4. **Silo shutdown** — the grain service is stopped and disposed.
</Steps>

## Common Use Cases

- **Background cleanup** — periodically purge expired data or temporary resources.
- **Health monitoring** — collect and report silo-level health metrics.
- **External system polling** — poll external APIs and update grain state.
- **Event distribution** — receive events from external sources and dispatch them to grains.
- **Infrastructure coordination** — implement custom cluster-wide protocols.

<Aside type="tip">
  Grain services are ideal for work that needs to happen on every silo regardless of which grains are active. For work tied to specific grain identities, use regular grains with [reminders](/features/timers-and-reminders/).
</Aside>

## Next Steps

<CardGrid>
  <Card title="Grain Call Filters" icon="random">
    Intercept grain calls for cross-cutting concerns.
    [Learn more](/features/grain-call-filters/)
  </Card>
  <Card title="Grain Extensions" icon="puzzle">
    Add functionality to grains at runtime without modifying them.
    [Learn more](/features/grain-extensions/)
  </Card>
  <Card title="Timers and Reminders" icon="setting">
    Schedule periodic work inside regular grains.
    [Learn more](/features/timers-and-reminders/)
  </Card>
  <Card title="Silo Clustering" icon="puzzle">
    Understand the cluster that grain services run on.
    [Learn more](/features/silo-clustering/)
  </Card>
</CardGrid>
